//! Timing analysis report types.
//!
//! This module defines the output of static timing analysis: timing reports
//! with critical paths, slack values, achieved frequencies, and per-clock-domain
//! summaries. Reports are generated by the STA engine and consumed by the CLI
//! and report generation crate.

use aion_common::Ident;
use aion_source::Span;
use serde::{Deserialize, Serialize};

/// A complete timing analysis report for a design.
///
/// Contains per-clock-domain timing summaries, critical path details,
/// and an overall pass/fail determination based on whether all timing
/// constraints are met.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TimingReport {
    /// Per-clock-domain timing summaries.
    pub clock_domains: Vec<ClockDomainTiming>,
    /// The N worst critical paths across all clock domains.
    pub critical_paths: Vec<CriticalPath>,
    /// Worst negative slack across all endpoints (ns). Positive = met, negative = violated.
    pub worst_slack_ns: f64,
    /// Achieved maximum frequency based on worst critical path (MHz).
    pub achieved_frequency_mhz: f64,
    /// Target frequency from constraints (MHz). Zero if no clock defined.
    pub target_frequency_mhz: f64,
    /// Whether all timing constraints are met (worst_slack >= 0).
    pub met: bool,
}

impl TimingReport {
    /// Creates an empty timing report with all constraints met.
    pub fn empty() -> Self {
        Self {
            clock_domains: Vec::new(),
            critical_paths: Vec::new(),
            worst_slack_ns: 0.0,
            achieved_frequency_mhz: 0.0,
            target_frequency_mhz: 0.0,
            met: true,
        }
    }

    /// Returns the number of violating paths (negative slack).
    pub fn violation_count(&self) -> usize {
        self.critical_paths
            .iter()
            .filter(|p| p.slack_ns < 0.0)
            .count()
    }

    /// Returns the total number of analyzed endpoints.
    pub fn total_endpoints(&self) -> usize {
        self.clock_domains.iter().map(|d| d.endpoint_count).sum()
    }
}

/// Timing summary for a single clock domain.
///
/// Shows the worst slack and critical path count for one clock,
/// enabling per-domain timing closure analysis.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClockDomainTiming {
    /// The clock name for this domain.
    pub clock_name: Ident,
    /// Clock period in nanoseconds (from constraints).
    pub period_ns: f64,
    /// Worst negative slack in this domain (ns).
    pub worst_slack_ns: f64,
    /// Number of critical paths in this domain.
    pub critical_path_count: usize,
    /// Number of timing endpoints in this domain.
    pub endpoint_count: usize,
    /// Whether this domain meets its timing constraint.
    pub met: bool,
}

/// A single critical timing path through the design.
///
/// Represents the longest (worst-case) delay from a source endpoint
/// to a destination endpoint, with the detailed breakdown of each
/// element contributing to the total delay.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CriticalPath {
    /// The source endpoint of this path.
    pub from: TimingEndpoint,
    /// The destination endpoint of this path.
    pub to: TimingEndpoint,
    /// Total path delay in nanoseconds.
    pub delay_ns: f64,
    /// Slack at the destination (required_time - arrival_time). Negative = violated.
    pub slack_ns: f64,
    /// Ordered list of elements along this path.
    pub elements: Vec<PathElement>,
}

/// An element along a critical timing path.
///
/// Each element represents one node in the path with its individual
/// delay contribution and cumulative delay up to that point.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PathElement {
    /// Human-readable name of this node (e.g., "lut_0", "net_clk").
    pub node_name: String,
    /// Description of the node type (e.g., "LUT", "Route", "FF").
    pub node_type: String,
    /// Individual delay contribution of this element (ns).
    pub delay_ns: f64,
    /// Cumulative delay from the path start to this element (ns).
    pub cumulative_ns: f64,
    /// Device location string (e.g., "SLICE_X0Y0"), if available.
    pub location: Option<String>,
    /// Source code span associated with this element, if available.
    pub source_span: Option<Span>,
}

/// An endpoint of a timing path (source or destination).
///
/// Identifies a specific node and optionally a specific pin at that node.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TimingEndpoint {
    /// The node name or identifier.
    pub node: Ident,
    /// Optional pin name (e.g., "D", "Q", "CLK").
    pub pin: Option<String>,
}

#[cfg(test)]
mod tests {
    use super::*;
    use aion_common::Interner;

    fn make_interner() -> Interner {
        Interner::new()
    }

    #[test]
    fn empty_report() {
        let report = TimingReport::empty();
        assert!(report.met);
        assert_eq!(report.violation_count(), 0);
        assert_eq!(report.total_endpoints(), 0);
        assert!(report.critical_paths.is_empty());
        assert!(report.clock_domains.is_empty());
    }

    #[test]
    fn report_with_met_paths() {
        let interner = make_interner();
        let report = TimingReport {
            clock_domains: vec![ClockDomainTiming {
                clock_name: interner.get_or_intern("clk"),
                period_ns: 10.0,
                worst_slack_ns: 2.5,
                critical_path_count: 1,
                endpoint_count: 10,
                met: true,
            }],
            critical_paths: vec![CriticalPath {
                from: TimingEndpoint {
                    node: interner.get_or_intern("ff_src"),
                    pin: Some("Q".into()),
                },
                to: TimingEndpoint {
                    node: interner.get_or_intern("ff_dst"),
                    pin: Some("D".into()),
                },
                delay_ns: 7.5,
                slack_ns: 2.5,
                elements: vec![
                    PathElement {
                        node_name: "ff_src/Q".into(),
                        node_type: "FF".into(),
                        delay_ns: 0.3,
                        cumulative_ns: 0.3,
                        location: Some("SLICE_X0Y0".into()),
                        source_span: None,
                    },
                    PathElement {
                        node_name: "net_0".into(),
                        node_type: "Route".into(),
                        delay_ns: 1.2,
                        cumulative_ns: 1.5,
                        location: None,
                        source_span: None,
                    },
                ],
            }],
            worst_slack_ns: 2.5,
            achieved_frequency_mhz: 133.3,
            target_frequency_mhz: 100.0,
            met: true,
        };
        assert!(report.met);
        assert_eq!(report.violation_count(), 0);
        assert_eq!(report.total_endpoints(), 10);
    }

    #[test]
    fn report_with_violations() {
        let interner = make_interner();
        let report = TimingReport {
            clock_domains: vec![ClockDomainTiming {
                clock_name: interner.get_or_intern("clk"),
                period_ns: 5.0,
                worst_slack_ns: -1.5,
                critical_path_count: 2,
                endpoint_count: 20,
                met: false,
            }],
            critical_paths: vec![
                CriticalPath {
                    from: TimingEndpoint {
                        node: interner.get_or_intern("a"),
                        pin: None,
                    },
                    to: TimingEndpoint {
                        node: interner.get_or_intern("b"),
                        pin: None,
                    },
                    delay_ns: 6.5,
                    slack_ns: -1.5,
                    elements: vec![],
                },
                CriticalPath {
                    from: TimingEndpoint {
                        node: interner.get_or_intern("c"),
                        pin: None,
                    },
                    to: TimingEndpoint {
                        node: interner.get_or_intern("d"),
                        pin: None,
                    },
                    delay_ns: 4.0,
                    slack_ns: 1.0,
                    elements: vec![],
                },
            ],
            worst_slack_ns: -1.5,
            achieved_frequency_mhz: 153.8,
            target_frequency_mhz: 200.0,
            met: false,
        };
        assert!(!report.met);
        assert_eq!(report.violation_count(), 1);
        assert_eq!(report.total_endpoints(), 20);
    }

    #[test]
    fn clock_domain_timing_construction() {
        let interner = make_interner();
        let cdt = ClockDomainTiming {
            clock_name: interner.get_or_intern("sys_clk"),
            period_ns: 8.0,
            worst_slack_ns: 0.5,
            critical_path_count: 3,
            endpoint_count: 50,
            met: true,
        };
        assert_eq!(cdt.period_ns, 8.0);
        assert_eq!(cdt.critical_path_count, 3);
        assert!(cdt.met);
    }

    #[test]
    fn path_element_with_location() {
        let elem = PathElement {
            node_name: "lut_3".into(),
            node_type: "LUT6".into(),
            delay_ns: 0.124,
            cumulative_ns: 3.456,
            location: Some("SLICE_X12Y34".into()),
            source_span: Some(Span::DUMMY),
        };
        assert_eq!(elem.location.as_deref(), Some("SLICE_X12Y34"));
        assert!(elem.source_span.is_some());
    }

    #[test]
    fn timing_endpoint_without_pin() {
        let interner = make_interner();
        let ep = TimingEndpoint {
            node: interner.get_or_intern("port_a"),
            pin: None,
        };
        assert!(ep.pin.is_none());
    }

    #[test]
    fn timing_endpoint_with_pin() {
        let interner = make_interner();
        let ep = TimingEndpoint {
            node: interner.get_or_intern("ff_0"),
            pin: Some("D".into()),
        };
        assert_eq!(ep.pin.as_deref(), Some("D"));
    }

    #[test]
    fn report_serde_roundtrip() {
        let interner = make_interner();
        let report = TimingReport {
            clock_domains: vec![ClockDomainTiming {
                clock_name: interner.get_or_intern("clk"),
                period_ns: 10.0,
                worst_slack_ns: 1.0,
                critical_path_count: 1,
                endpoint_count: 5,
                met: true,
            }],
            critical_paths: vec![],
            worst_slack_ns: 1.0,
            achieved_frequency_mhz: 111.1,
            target_frequency_mhz: 100.0,
            met: true,
        };
        let json = serde_json::to_string(&report).unwrap();
        let restored: TimingReport = serde_json::from_str(&json).unwrap();
        assert!(restored.met);
        assert_eq!(restored.clock_domains.len(), 1);
    }

    #[test]
    fn multiple_clock_domains() {
        let interner = make_interner();
        let report = TimingReport {
            clock_domains: vec![
                ClockDomainTiming {
                    clock_name: interner.get_or_intern("clk_fast"),
                    period_ns: 5.0,
                    worst_slack_ns: 0.2,
                    critical_path_count: 2,
                    endpoint_count: 30,
                    met: true,
                },
                ClockDomainTiming {
                    clock_name: interner.get_or_intern("clk_slow"),
                    period_ns: 20.0,
                    worst_slack_ns: 10.0,
                    critical_path_count: 0,
                    endpoint_count: 10,
                    met: true,
                },
            ],
            critical_paths: vec![],
            worst_slack_ns: 0.2,
            achieved_frequency_mhz: 208.3,
            target_frequency_mhz: 200.0,
            met: true,
        };
        assert_eq!(report.total_endpoints(), 40);
    }
}
